{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/cris/Code/pokemon-league/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/cris/Code/pokemon-league/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar axios = require('axios');\n\nvar _require = require('./error.js'),\n    handleError = _require.handleError;\n\nexports.getJSON = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(values, url, cb) {\n    var options, cachedResult, response;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            options = {\n              baseURL: \"\".concat(values.protocol).concat(values.hostName, \"/\"),\n              timeout: values.timeout\n            };\n            _context.prev = 1;\n            // retrive possible content from memory-cache\n            cachedResult = values.cache.get(url);\n\n            if (!(cachedResult !== null)) {\n              _context.next = 8;\n              break;\n            }\n\n            if (cb) {\n              // call callback without errors\n              cb(cachedResult, false);\n            }\n\n            return _context.abrupt(\"return\", cachedResult);\n\n          case 8:\n            _context.next = 10;\n            return axios.get(url, options);\n\n          case 10:\n            response = _context.sent;\n\n            if (!(response.statusCode !== undefined && response.statusCode !== 200)) {\n              _context.next = 15;\n              break;\n            }\n\n            handleError(response, cb);\n            _context.next = 22;\n            break;\n\n          case 15:\n            // if everything was good\n            // cache the object in memory-cache\n            // only if cacheLimit > 0\n            response = response.data;\n\n            if (values.cacheLimit > 0) {\n              values.cache.put(url, response, values.cacheLimit);\n            } // if a callback is present\n\n\n            if (!cb) {\n              _context.next = 21;\n              break;\n            }\n\n            // call it, without errors\n            cb(response, false);\n            _context.next = 22;\n            break;\n\n          case 21:\n            return _context.abrupt(\"return\", response);\n\n          case 22:\n            _context.next = 27;\n            break;\n\n          case 24:\n            _context.prev = 24;\n            _context.t0 = _context[\"catch\"](1);\n            handleError(_context.t0, cb);\n\n          case 27:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[1, 24]]);\n  }));\n\n  return function (_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/Users/cris/Code/pokemon-league/node_modules/pokedex-promise-v2/src/getter.js"],"names":["axios","require","handleError","exports","getJSON","values","url","cb","options","baseURL","protocol","hostName","timeout","cachedResult","cache","get","response","statusCode","undefined","data","cacheLimit","put"],"mappings":";;;;AAAA,IAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AAEA,eAAwBA,OAAO,CAAC,YAAD,CAA/B;AAAA,IAAQC,WAAR,YAAQA,WAAR;;AAGAC,OAAO,CAACC,OAAR;AAAA,sEAAkB,iBAAOC,MAAP,EAAeC,GAAf,EAAoBC,EAApB;AAAA;AAAA;AAAA;AAAA;AAAA;AACVC,YAAAA,OADU,GACA;AACVC,cAAAA,OAAO,YAAKJ,MAAM,CAACK,QAAZ,SAAuBL,MAAM,CAACM,QAA9B,MADG;AAEVC,cAAAA,OAAO,EAAEP,MAAM,CAACO;AAFN,aADA;AAAA;AAMV;AACMC,YAAAA,YAPI,GAOWR,MAAM,CAACS,KAAP,CAAaC,GAAb,CAAiBT,GAAjB,CAPX;;AAAA,kBAQNO,YAAY,KAAK,IARX;AAAA;AAAA;AAAA;;AASN,gBAAIN,EAAJ,EAAQ;AACJ;AACAA,cAAAA,EAAE,CAACM,YAAD,EAAe,KAAf,CAAF;AACH;;AAZK,6CAaCA,YAbD;;AAAA;AAAA;AAAA,mBAeeb,KAAK,CAACe,GAAN,CAAUT,GAAV,EAAeE,OAAf,CAff;;AAAA;AAeFQ,YAAAA,QAfE;;AAAA,kBAiBFA,QAAQ,CAACC,UAAT,KAAwBC,SAAxB,IAAqCF,QAAQ,CAACC,UAAT,KAAwB,GAjB3D;AAAA;AAAA;AAAA;;AAkBFf,YAAAA,WAAW,CAACc,QAAD,EAAWT,EAAX,CAAX;AAlBE;AAAA;;AAAA;AAoBF;AACA;AACA;AACAS,YAAAA,QAAQ,GAAGA,QAAQ,CAACG,IAApB;;AAEA,gBAAId,MAAM,CAACe,UAAP,GAAoB,CAAxB,EAA2B;AACvBf,cAAAA,MAAM,CAACS,KAAP,CAAaO,GAAb,CAAiBf,GAAjB,EAAsBU,QAAtB,EAAgCX,MAAM,CAACe,UAAvC;AACH,aA3BC,CA6BF;;;AA7BE,iBA8BEb,EA9BF;AAAA;AAAA;AAAA;;AA+BE;AACAA,YAAAA,EAAE,CAACS,QAAD,EAAW,KAAX,CAAF;AAhCF;AAAA;;AAAA;AAAA,6CAkCSA,QAlCT;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAuCVd,YAAAA,WAAW,cAAQK,EAAR,CAAX;;AAvCU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAlB;;AAAA;AAAA;AAAA;AAAA","sourcesContent":["const axios = require('axios')\n\nconst { handleError } = require('./error.js')\n\n\nexports.getJSON = async (values, url, cb) => {\n    let options = {\n        baseURL: `${values.protocol}${values.hostName}/`,\n        timeout: values.timeout\n    }\n    try {\n        // retrive possible content from memory-cache\n        const cachedResult = values.cache.get(url)\n        if (cachedResult !== null) {\n            if (cb) {\n                // call callback without errors\n                cb(cachedResult, false)\n            }\n            return cachedResult\n        } else {\n            let response = await axios.get(url, options)\n            // if there is an error\n            if (response.statusCode !== undefined && response.statusCode !== 200) {\n                handleError(response, cb)\n            } else {\n                // if everything was good\n                // cache the object in memory-cache\n                // only if cacheLimit > 0\n                response = response.data\n\n                if (values.cacheLimit > 0) {\n                    values.cache.put(url, response, values.cacheLimit)\n                }\n\n                // if a callback is present\n                if (cb) {\n                    // call it, without errors\n                    cb(response, false)\n                } else {\n                    return response\n                }\n            }\n        }\n    } catch (error) {\n        handleError(error, cb)\n    }\n}\n"]},"metadata":{},"sourceType":"script"}